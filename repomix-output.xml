This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  services/
    type-formatter.ts
  types/
    openpkg.ts
  utils/
    validate.ts
  ai-agent.ts
  base-parser.ts
  cli.ts
.gitignore
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/services/type-formatter.ts">
/**
 * Service for formatting types for output
 */
export class TypeFormatter {
  private static readonly BUILT_IN_TYPES = new Set([
    'string', 'number', 'boolean', 'object', 'any', 'void', 'unknown', 'never',
    'null', 'undefined', 'bigint', 'symbol',
    'Array', 'Promise', 'Object', 'String', 'Number', 'Boolean', 'Date', 'RegExp',
    'Map', 'Set', 'Error', 'ArrayBuffer', 'Uint8Array', 'ArrayBufferLike', 'BigInt'
  ]);

  /**
   * Create a $ref object for type references
   */
  static createRef(typeName: string): { $ref: string } {
    return { $ref: `#/types/${typeName}` };
  }

  /**
   * Check if a type name is a custom type (not built-in)
   */
  static isCustomType(typeName: string): boolean {
    // NEW: Exclude literals
    if (
      typeName.match(/^\d+(\.\d+)?$/) ||  // Numbers
      typeName.match(/^\d+n$/) ||         // BigInt literals
      typeName.match(/^"[^"]*"$/) ||      // Strings
      typeName === 'true' || typeName === 'false' ||  // Booleans
      typeName === 'null' || typeName === 'undefined'
    ) {
      return false;
    }
    // Exclude single letter type parameters (generic type parameters like T, U, K, V)
    if (typeName.match(/^[A-Z]$/)) {
      return false;
    }
    return !this.BUILT_IN_TYPES.has(typeName);
  }

  /**
   * Clean up type text by removing import() syntax
   */
  static cleanTypeText(typeText: string): string {
    return typeText
      .replace(/import\([^)]+\)\.(\w+)/g, '$1')
      .replace(/typeof import\([^)]+\)\.(\w+)/g, '$1');
  }

  /**
   * Extract type name from complex type strings
   */
  static extractTypeName(typeText: string): string | null {
    // Handle import(...).TypeName pattern
    const importMatch = typeText.match(/import\([^)]+\)\.(\w+)$/);
    if (importMatch) {
      return importMatch[1];
    }
    
    // Check if it's a simple type reference
    const simpleMatch = typeText.match(/^([A-Z]\w*)$/);
    if (simpleMatch) {
      return simpleMatch[1];
    }
    
    return null;
  }

  /**
   * Convert type string to appropriate format (string or $ref)
   */
  static formatForOutput(
    typeStr: string,
    collectedTypes: Map<string, any>
  ): string | { $ref: string } {
    // First, try to extract a type name from the original string
    const typeName = this.extractTypeName(typeStr);
    if (typeName && this.isCustomType(typeName)) {
      // Always create a ref for custom type names, even if not yet in collectedTypes
      // This handles the case where types are collected after functions are processed
      return this.createRef(typeName);
    }
    
    const cleaned = this.cleanTypeText(typeStr);
    
    // NEW: Detect numeric literals and return as string
    if (cleaned.match(/^\d+(\.\d+)?$/)) {
      return cleaned;  // e.g., "3.141592653589793"
    }
    
    // NEW: Detect BigInt literals and return as string
    if (cleaned.match(/^\d+n$/)) {
      return cleaned;  // e.g., "3n", "100n"
    }
    
    // NEW: Detect string literals (with quotes) and return as string
    if (cleaned.match(/^"[^"]*"$/)) {
      return cleaned;  // e.g., "\"hello\""
    }
    
    // NEW: Detect boolean literals and return as string
    if (cleaned === 'true' || cleaned === 'false') {
      return cleaned;  // e.g., "true" or "false"
    }
    
    // NEW: Detect null and undefined literals
    if (cleaned === 'null' || cleaned === 'undefined') {
      return cleaned;
    }
    
    // Check if it's a simple type reference (no generics, unions, etc.)
    const simpleTypeMatch = cleaned.match(/^([A-Z][\w]*)$/);
    if (simpleTypeMatch) {
      const simpleTypeName = simpleTypeMatch[1];
      if (this.isCustomType(simpleTypeName)) {
        // Always create a ref for custom type names
        return this.createRef(simpleTypeName);
      }
    }
    
    // For complex types (like objects), handle them recursively
    if (cleaned.startsWith('{') && cleaned.endsWith('}')) {
      return this.formatComplexType(cleaned, collectedTypes);
    }
    
    // For complex types or unrecognized, return as string
    return cleaned;
  }

  /**
   * Extract type names from a type string or $ref object
   */
  static extractTypeNames(type: string | { $ref: string }): string[] {
    const names = new Set<string>();
    
    // Handle $ref objects
    if (typeof type === 'object' && type.$ref) {
      const match = type.$ref.match(/#\/types\/(\w+)/);
      if (match) {
        names.add(match[1]);
      }
      return Array.from(names);
    }
    
    // Handle string types
    if (typeof type === 'string') {
      const cleaned = this.cleanTypeText(type);
      
      // Match type names (capital letters followed by word characters)
      // But exclude those that are part of camelCase property names
      // Use word boundary to ensure we're matching whole type names
      const matches = cleaned.match(/\b[A-Z]\w+\b/g);
      if (matches) {
        matches.forEach(match => {
          if (this.isCustomType(match)) {
            names.add(match);
          }
        });
      }
    }
    
    return Array.from(names);
  }

  /**
   * Format a resolved type object to string
   */
  static formatResolvedType(typeObj: any): string {
    if (typeof typeObj === 'string') return typeObj;
    
    if (typeObj.kind === 'interface') {
      const props = typeObj.properties.map((p: any) => 
        `${p.name}${p.optional ? '?' : ''}: ${this.formatResolvedType(p.type)}`
      );
      return `{${props.join('; ')}}`;
    }
    
    if (typeObj.kind === 'function') {
      const params = typeObj.parameters.map((p: any) => 
        `${p.name}: ${this.formatResolvedType(p.type)}`
      );
      return `(${params.join(', ')}) => ${this.formatResolvedType(typeObj.returnType)}`;
    }
    
    if (typeObj.type === 'array' && typeObj.elementType) {
      return `${this.formatResolvedType(typeObj.elementType)}[]`;
    }
    
    if (typeObj.kind === 'tuple' && typeObj.elements) {
      return `[${typeObj.elements.map((e: any) => this.formatResolvedType(e)).join(', ')}]`;
    }
    
    return 'unknown';
  }

  /**
   * Normalize type strings (handle array syntax, etc.)
   */
  static normalizeTypeString(typeStr: string): string {
    // Convert Array<T> to T[]
    typeStr = typeStr.replace(/Array<([^>]+)>/g, '$1[]');
    
    // Remove extra whitespace
    typeStr = typeStr.replace(/\s+/g, ' ').trim();
    
    return typeStr;
  }

  /**
   * Format complex types (objects, unions) recursively
   */
  private static formatComplexType(
    typeStr: string,
    collectedTypes: Map<string, any>
  ): string {
    // Handle object types
    if (typeStr.startsWith('{') && typeStr.endsWith('}')) {
      // Extract the content between braces
      const content = typeStr.slice(1, -1).trim();
      
      // Split properties by semicolon or comma (handle both formats)
      const separator = content.includes(';') ? ';' : ',';
      const props = content.split(separator).map(p => p.trim()).filter(p => p);
      
      const formattedProps = props.map(prop => {
        // Match property pattern: "name: type"
        const colonIndex = prop.indexOf(':');
        if (colonIndex === -1) return prop; // Malformed, return as-is
        
        const key = prop.substring(0, colonIndex).trim();
        const value = prop.substring(colonIndex + 1).trim();
        
        // Recursively format the value type
        const formattedValue = this.formatForOutput(value, collectedTypes);
        const valueStr = typeof formattedValue === 'string' 
          ? formattedValue 
          : JSON.stringify(formattedValue);
        
        return `${key}: ${valueStr}`;
      });
      
      return `{${formattedProps.join('; ')}}`;
    }
    
    // Handle array types
    if (typeStr.endsWith('[]')) {
      const elementType = typeStr.slice(0, -2).trim();
      const formattedElement = this.formatForOutput(elementType, collectedTypes);
      const elementStr = typeof formattedElement === 'string' 
        ? formattedElement 
        : JSON.stringify(formattedElement);
      return `${elementStr}[]`;
    }
    
    // Handle union types
    if (typeStr.includes(' | ')) {
      const types = typeStr.split(' | ').map(t => t.trim());
      const formattedTypes = types.map(t => {
        const formatted = this.formatForOutput(t, collectedTypes);
        return typeof formatted === 'string' ? formatted : JSON.stringify(formatted);
      });
      return formattedTypes.join(' | ');
    }
    
    // Handle intersection types
    if (typeStr.includes(' & ')) {
      const types = typeStr.split(' & ').map(t => t.trim());
      const formattedTypes = types.map(t => {
        const formatted = this.formatForOutput(t, collectedTypes);
        return typeof formatted === 'string' ? formatted : JSON.stringify(formatted);
      });
      return formattedTypes.join(' & ');
    }
    
    // Fallback for other complex types
    return typeStr;
  }
}
</file>

<file path="src/types/openpkg.ts">
import { z } from "zod";

// Type can be a string, a $ref object, or an inline type definition
const typeRefSchema = z.union([
  z.string(),
  z.object({
    $ref: z.string(), // Reference to a type in the types array
  }),
  z.object({
    name: z.string(),
    kind: z.enum(["class", "interface", "type", "enum"]),
    properties: z.array(
      z.object({
        name: z.string(),
        type: z.string(),
        optional: z.boolean().optional(),
        description: z.string().optional(),
      })
    ).optional(),
    members: z.array(
      z.object({
        name: z.string(),
        value: z.union([z.string(), z.number()]).optional(),
        description: z.string().optional(),
      })
    ).optional(),
    type: z.string().optional(),
  })
]);

const classMemberSchema = z.object({
  id: z.string(),
  name: z.string(),
  kind: z.enum(["method", "property", "constructor", "accessor"]),
  visibility: z.enum(["public", "private", "protected"]).optional(),
  signatures: z
    .array(
      z.object({
        parameters: z
          .array(
            z.object({
              name: z.string(),
              type: typeRefSchema.optional(),
              optional: z.boolean().optional(),
              description: z.string().optional(),
            })
          )
          .optional(),
        returnType: typeRefSchema.optional(),
      })
    )
    .optional(),
  type: typeRefSchema.optional(),
  description: z.string().optional(),
  examples: z.array(z.string()).optional(),
  flags: z.record(z.string(), z.boolean()).optional(),
});

const enumMemberSchema = z.object({
  id: z.string(),
  name: z.string(),
  value: z.union([z.string(), z.number()]).optional(),
  description: z.string().optional(),
});

const memberSchema = z.union([classMemberSchema, enumMemberSchema]);

export const openPkgSchema = z.object({
  openpkg: z.literal("1.0.0"),
  meta: z.object({
    name: z.string(),
    version: z.string(),
    description: z.string().optional(),
    license: z.string().optional(),
    repository: z.string().optional(),
    ecosystem: z.string().default("js/ts"),
  }),
  exports: z.array(
    z.object({
      id: z.string(),
      name: z.string(),
      kind: z.enum(["function", "class", "variable", "interface", "type", "enum", "module", "namespace", "reference"]),
      signatures: z
        .array(
          z.object({
            parameters: z
              .array(
                z.object({
                  name: z.string(),
                  type: typeRefSchema.optional(),
                  optional: z.boolean().optional(),
                  description: z.string().optional(),
                })
              )
              .optional(),
            returnType: typeRefSchema.optional(),
          })
        )
        .optional(),
      members: z.array(memberSchema).optional(),
      type: typeRefSchema.optional(), // For variables/accessors
      description: z.string().optional(),
      examples: z.array(z.string()).optional(),
      source: z
        .object({
          file: z.string().optional(),
          line: z.number().optional(),
          url: z.string().optional(),
        })
        .optional(),
      flags: z.record(z.string(), z.unknown()).optional(), // Changed to z.unknown() for flexibility
      tags: z.array(z.object({ 
        name: z.string(), 
        text: z.string() 
      })).optional(),
    })
  ),
  types: z.array(
    z.object({
      id: z.string(),
      name: z.string(),
      kind: z.enum(["class", "interface", "type", "enum"]),
      description: z.string().optional(),
      // For classes - constructor parameters define the shape
      parameters: z.array(
        z.object({
          name: z.string(),
          type: z.string(),
          optional: z.boolean().optional(),
          description: z.string().optional(),
        })
      ).optional(),
      // For interfaces and type aliases - properties define the shape
      properties: z.array(
        z.object({
          name: z.string(),
          type: z.string(),
          optional: z.boolean().optional(),
          description: z.string().optional(),
        })
      ).optional(),
      // For enums - members with values
      members: z.array(
        z.object({
          name: z.string(),
          value: z.union([z.string(), z.number()]).optional(),
          description: z.string().optional(),
        })
      ).optional(),
      // For type aliases - the actual type definition
      type: z.string().optional(),
      source: z.object({
        file: z.string().optional(),
        line: z.number().optional(),
        url: z.string().optional(),
      }).optional(),
      // JSDoc tags
      tags: z.array(z.object({ 
        name: z.string(), 
        text: z.string() 
      })).optional(),
      // Raw comments fallback
      rawComments: z.string().optional(),
    })
  ).optional(),
  examples: z.array(z.object({})).optional(),
  extensions: z.record(z.string(), z.unknown()).optional(),
});
</file>

<file path="src/utils/validate.ts">
import { openPkgSchema } from "../types/openpkg";

export function validateOpenPkg(data: any) {
  const result = openPkgSchema.safeParse(data);
  if (!result.success) {
    throw new Error(
      `Invalid OpenPkg spec: ${JSON.stringify(result.error.errors, null, 2)}`
    );
  }
  return result.data;
}
</file>

<file path="src/ai-agent.ts">
// src/ai-agent.ts
import { generateObject } from 'ai';
import { createAnthropic } from '@ai-sdk/anthropic';
import { z } from 'zod';
import { openPkgSchema } from './types/openpkg'; // Reused

const anthropic = createAnthropic({ apiKey: process.env.ANTHROPIC_API_KEY });

export async function resolveSpec(baseSpec: any, depth: number) {
  if (!process.env.ANTHROPIC_API_KEY) {
    console.log('Paid resolution requires API key'); // Stub for open-source
    return baseSpec;
  }

  // AI prompt to resolve/expand (e.g., traverse deps, inline types)
  const { object: resolvedSpec } = await generateObject({
    model: anthropic("claude-4-opus-20250514"),
    schema: openPkgSchema, // Enforce structure
    prompt: `Resolve and expand this base spec: ${JSON.stringify(baseSpec)}. Depth: ${depth}. Lookup remote packages via unpkg/GitHub if needed, inline all types.`
  });

  // Add tool calls if needed (e.g., for unpkg fetchâ€”implement as functions)
  // Validate with utils/validate.ts

  return resolvedSpec;
}
</file>

<file path="src/base-parser.ts">
// src/base-parser.ts
import { Project, SourceFile, Node } from 'ts-morph';
import { TypeFormatter } from './services/type-formatter'; // Reused
import { z } from 'zod';
import { openPkgSchema } from './types/openpkg'; // Reused

export function generateBaseSpec(entryFile: string): z.infer<typeof openPkgSchema> {
  const project = new Project({ /* minimal config */ });
  const sourceFile = project.addSourceFileAtPath(entryFile);

  // Basic extraction: Find exports, signatures, create $refs for types
  const exports = [];
  for (const [name, decls] of sourceFile.getExportedDeclarations()) {
    const decl = decls[0];
    // Simple handling for functions/classes (expand as needed, but keep light)
    if (Node.isFunctionDeclaration(decl)) {
      exports.push({
        id: name,
        name,
        kind: 'function' as const,
        signatures: [{ /* extract params/return with TypeFormatter.createRef() for types */ }]
      });
    }
    // Add $refs for dependent types (no inline resolution)
  }

  const spec = {
    openpkg: '1.0.0' as const,
    meta: { 
      name: 'package-name',
      version: '1.0.0',
      ecosystem: 'js/ts'
    },
    exports,
    types: [] // Empty or basic placeholders with $ref
  };

  return spec;
}
</file>

<file path="src/cli.ts">
// src/cli.ts
import { Command } from 'commander';
import chalk from 'chalk';
import { generateBaseSpec } from './base-parser';
import { resolveSpec } from './ai-agent';
import { validateOpenPkg } from './utils/validate'; // Reused

const program = new Command();
program
  .argument('[entry]', 'File path or package')
  .option('--function <names>', 'Functions to focus on')
  .option('--depth <number>', 'Resolution depth (0 for base spec)', '0')
  .action(async (entry, options) => {
    let spec = generateBaseSpec(entry || 'index.ts'); // Base parse
    if (options.depth > 0) {
      spec = await resolveSpec(spec, parseInt(options.depth)); // AI resolution
    }
    try {
      const validatedSpec = validateOpenPkg(spec);
      // Write to output.json
      console.log(JSON.stringify(validatedSpec, null, 2));
    } catch (error) {
      console.log(chalk.yellow('Validation issues:', (error as Error).message));
    }
  });
program.parse();
</file>

<file path=".gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="package.json">
{
  "name": "openpkg",
  "version": "1.0.0",
  "scripts": {
    "start": "bun run src/cli.ts",
    "test": "bun test"
  },
  "dependencies": {
    "ai": "^4.3.19",
    "@ai-sdk/anthropic": "^1.2.12",
    "commander": "^14.0.0",
    "chalk": "^5.4.1",
    "zod": "^4.0.5",
    "js-yaml": "^4.1.0",
    "ts-morph": "^26.0.0"
  },
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  }
}
</file>

<file path="README.md">
# openpkg

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run index.ts
```

This project was created using `bun init` in bun v1.2.13. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": [
      "ESNext"
    ],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "strict": true
  },
  "include": [
    "src/**/*.ts"
  ]
}
</file>

</files>
