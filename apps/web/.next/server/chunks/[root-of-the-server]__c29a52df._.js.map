{"version":3,"sources":["../../../../../packages/db/src/limits.ts","../../../../../packages/db/src/index.ts","../../../../../packages/api-shared/src/utils/api-keys.ts","../../../../../packages/api-shared/src/middleware/api-key.ts","../../../../../packages/api-shared/src/env.ts","../../../../../packages/api-shared/src/errors.ts","../../../../../packages/api-shared/src/middleware/index.ts","../../../../../packages/api-shared/src/middleware/rate-limit.ts","../../../../../packages/api-shared/src/utils/index.ts"],"sourcesContent":["export const PLAN_LIMITS = {\n  free: {\n    aiCallsPerMonth: 0,\n    privateRepos: 0,\n    analysesPerDay: 100,\n    members: 1,\n    historyDays: 0,\n  },\n  team: {\n    aiCallsPerMonth: 5_000,\n    privateRepos: Infinity,\n    analysesPerDay: 1_000,\n    members: Infinity,\n    historyDays: 30,\n  },\n  pro: {\n    aiCallsPerMonth: 25_000,\n    privateRepos: Infinity,\n    analysesPerDay: 10_000,\n    members: Infinity,\n    historyDays: 90,\n  },\n  enterprise: {\n    aiCallsPerMonth: Infinity,\n    privateRepos: Infinity,\n    analysesPerDay: Infinity,\n    members: Infinity,\n    historyDays: 365,\n  },\n  hero: {\n    aiCallsPerMonth: 25_000,\n    privateRepos: Infinity,\n    analysesPerDay: 10_000,\n    members: Infinity,\n    historyDays: 90,\n  },\n} as const;\n\nexport type Plan = keyof typeof PLAN_LIMITS;\n\nexport function getPlanLimits(plan: Plan) {\n  return PLAN_LIMITS[plan] ?? PLAN_LIMITS.free;\n}\n\nexport function canUseAI(plan: Plan): boolean {\n  return getPlanLimits(plan).aiCallsPerMonth > 0;\n}\n\nexport function canAccessPrivateRepos(plan: Plan): boolean {\n  return getPlanLimits(plan).privateRepos > 0;\n}\n","export * from './limits';\nexport * from './schema';\n","import { createHash } from 'node:crypto';\nimport { nanoid } from 'nanoid';\n\nconst KEY_PREFIX = 'doccov_';\n\nexport function generateApiKey(): { key: string; hash: string; prefix: string } {\n  const random = nanoid(32);\n  const key = `${KEY_PREFIX}${random}`;\n  const hash = hashApiKey(key);\n  const prefix = key.slice(0, 12);\n  return { key, hash, prefix };\n}\n\nexport function hashApiKey(key: string): string {\n  return createHash('sha256').update(key).digest('hex');\n}\n\nexport function isValidKeyFormat(key: string): boolean {\n  return key.startsWith(KEY_PREFIX) && key.length === KEY_PREFIX.length + 32;\n}\n","import type { Database } from '@doccov/db';\nimport type { Kysely } from 'kysely';\nimport { hashApiKey, isValidKeyFormat } from '../utils/api-keys';\n\nexport interface ApiKeyContext {\n  apiKey: { id: string; orgId: string; name: string };\n  org: { id: string; plan: string; aiCallsUsed: number; aiCallsResetAt: Date | null };\n}\n\nexport type ApiKeyValidationResult =\n  | {\n      ok: true;\n      context: ApiKeyContext;\n    }\n  | {\n      ok: false;\n      error: string;\n      status: number;\n      docs?: string;\n      upgrade?: string;\n    };\n\n/**\n * Validate an API key from a request\n * Framework-agnostic - works with any Request object\n */\nexport async function validateApiKey(\n  request: Request,\n  db: Kysely<Database>\n): Promise<ApiKeyValidationResult> {\n  const authHeader = request.headers.get('Authorization');\n\n  if (!authHeader) {\n    return {\n      ok: false,\n      error: 'API key required',\n      status: 401,\n      docs: 'https://docs.doccov.com/api-keys',\n    };\n  }\n\n  if (!authHeader.startsWith('Bearer ')) {\n    return {\n      ok: false,\n      error: 'Invalid Authorization header. Use: Bearer <api_key>',\n      status: 401,\n    };\n  }\n\n  const key = authHeader.slice(7);\n\n  if (!isValidKeyFormat(key)) {\n    return {\n      ok: false,\n      error: 'Invalid API key format',\n      status: 401,\n    };\n  }\n\n  const keyHash = hashApiKey(key);\n\n  const result = await db\n    .selectFrom('api_keys')\n    .innerJoin('organizations', 'organizations.id', 'api_keys.orgId')\n    .where('api_keys.keyHash', '=', keyHash)\n    .where((eb) =>\n      eb.or([\n        eb('api_keys.expiresAt', 'is', null),\n        eb('api_keys.expiresAt', '>', new Date()),\n      ])\n    )\n    .select([\n      'api_keys.id as keyId',\n      'api_keys.orgId',\n      'api_keys.name as keyName',\n      'organizations.plan',\n      'organizations.aiCallsUsed',\n      'organizations.aiCallsResetAt',\n    ])\n    .executeTakeFirst();\n\n  if (!result) {\n    return {\n      ok: false,\n      error: 'Invalid or expired API key',\n      status: 401,\n    };\n  }\n\n  // Free tier shouldn't have API keys, but guard anyway\n  if (result.plan === 'free') {\n    return {\n      ok: false,\n      error: 'API access requires a paid plan',\n      status: 403,\n      upgrade: 'https://doccov.com/pricing',\n    };\n  }\n\n  // Update last used (async, don't block)\n  db.updateTable('api_keys')\n    .set({ lastUsedAt: new Date() })\n    .where('id', '=', result.keyId)\n    .execute()\n    .catch(console.error);\n\n  return {\n    ok: true,\n    context: {\n      apiKey: {\n        id: result.keyId,\n        orgId: result.orgId,\n        name: result.keyName,\n      },\n      org: {\n        id: result.orgId,\n        plan: result.plan,\n        aiCallsUsed: result.aiCallsUsed,\n        aiCallsResetAt: result.aiCallsResetAt,\n      },\n    },\n  };\n}\n","import { z } from 'zod';\n\nconst envSchema = z.object({\n  // Database\n  DATABASE_URL: z.string().url(),\n\n  // GitHub OAuth\n  GITHUB_CLIENT_ID: z.string().min(1),\n  GITHUB_CLIENT_SECRET: z.string().min(1),\n\n  // GitHub App\n  GITHUB_APP_ID: z.string().min(1).optional(),\n  GITHUB_APP_PRIVATE_KEY: z.string().min(1).optional(),\n  GITHUB_APP_WEBHOOK_SECRET: z.string().min(1).optional(),\n\n  // Polar Billing\n  POLAR_ACCESS_TOKEN: z.string().min(1).optional(),\n  POLAR_WEBHOOK_SECRET: z.string().min(1).optional(),\n  POLAR_PRODUCT_TEAM: z.string().optional(),\n  POLAR_PRODUCT_PRO: z.string().optional(),\n\n  // AI\n  ANTHROPIC_API_KEY: z.string().min(1).optional(),\n  OPENAI_API_KEY: z.string().min(1).optional(),\n\n  // URLs\n  SITE_URL: z.string().url().default('http://localhost:3000'),\n  API_URL: z.string().url().default('http://localhost:3001'),\n  SANDBOX_URL: z.string().url().optional(),\n  SANDBOX_SECRET: z.string().min(1).optional(),\n\n  // Environment\n  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),\n});\n\nexport type Env = z.infer<typeof envSchema>;\n\nlet _env: Env | undefined;\n\nexport function getEnv(): Env {\n  if (!_env) {\n    const result = envSchema.safeParse(process.env);\n    if (!result.success) {\n      const formatted = result.error.flatten();\n      console.error('Invalid environment variables:');\n      for (const [key, errors] of Object.entries(formatted.fieldErrors)) {\n        console.error(`  ${key}: ${errors?.join(', ')}`);\n      }\n      throw new Error('Invalid environment configuration');\n    }\n    _env = result.data;\n  }\n  return _env;\n}\n\nexport function requireEnv<K extends keyof Env>(key: K): NonNullable<Env[K]> {\n  const env = getEnv();\n  const value = env[key];\n  if (value === undefined || value === null) {\n    throw new Error(`Missing required environment variable: ${key}`);\n  }\n  return value as NonNullable<Env[K]>;\n}\n","export class ApiError extends Error {\n  constructor(\n    message: string,\n    public status: number,\n    public code?: string,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n\n  toJSON() {\n    return {\n      error: this.message,\n      code: this.code,\n      details: this.details,\n    };\n  }\n}\n\nexport function badRequest(message: string, code?: string): ApiError {\n  return new ApiError(message, 400, code);\n}\n\nexport function unauthorized(message = 'Unauthorized', code?: string): ApiError {\n  return new ApiError(message, 401, code);\n}\n\nexport function forbidden(message = 'Forbidden', code?: string): ApiError {\n  return new ApiError(message, 403, code);\n}\n\nexport function notFound(message = 'Not found', code?: string): ApiError {\n  return new ApiError(message, 404, code);\n}\n\nexport function tooManyRequests(message = 'Too many requests', code?: string): ApiError {\n  return new ApiError(message, 429, code);\n}\n\nexport function internalError(message = 'Internal server error', code?: string): ApiError {\n  return new ApiError(message, 500, code);\n}\n\nexport function handleApiError(error: unknown): Response {\n  if (error instanceof ApiError) {\n    return Response.json(error.toJSON(), { status: error.status });\n  }\n\n  console.error('Unhandled error:', error);\n  return Response.json({ error: 'Internal server error' }, { status: 500 });\n}\n","export { validateApiKey, type ApiKeyContext, type ApiKeyValidationResult } from './api-key';\nexport {\n  checkRateLimit,\n  getClientIp,\n  withRateLimitHeaders,\n  type RateLimitOptions,\n  type RateLimitResult,\n} from './rate-limit';\n","interface RateLimitEntry {\n  count: number;\n  resetAt: number;\n}\n\n/**\n * In-memory rate limiter store\n * Can be swapped for Redis in production\n */\nclass RateLimitStore {\n  private store = new Map<string, RateLimitEntry>();\n\n  get(key: string): RateLimitEntry | undefined {\n    const entry = this.store.get(key);\n    if (entry && Date.now() > entry.resetAt) {\n      this.store.delete(key);\n      return undefined;\n    }\n    return entry;\n  }\n\n  increment(key: string, windowMs: number): RateLimitEntry {\n    const now = Date.now();\n    const existing = this.get(key);\n\n    if (existing) {\n      existing.count++;\n      return existing;\n    }\n\n    const entry: RateLimitEntry = {\n      count: 1,\n      resetAt: now + windowMs,\n    };\n    this.store.set(key, entry);\n    return entry;\n  }\n\n  cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.store.entries()) {\n      if (now > entry.resetAt) {\n        this.store.delete(key);\n      }\n    }\n  }\n}\n\nconst store = new RateLimitStore();\n\n// Cleanup expired entries every minute\nif (typeof setInterval !== 'undefined') {\n  setInterval(() => store.cleanup(), 60 * 1000).unref?.();\n}\n\nexport interface RateLimitOptions {\n  /** Time window in milliseconds */\n  windowMs: number;\n  /** Max requests per window */\n  max: number;\n  /** Optional key prefix */\n  prefix?: string;\n}\n\nexport interface RateLimitResult {\n  ok: boolean;\n  remaining: number;\n  limit: number;\n  resetAt: number;\n}\n\n/**\n * Get client IP from request headers\n */\nexport function getClientIp(request: Request): string {\n  const headers = request.headers;\n\n  // Check common proxy headers\n  const forwarded = headers.get('x-forwarded-for');\n  if (forwarded) {\n    return forwarded.split(',')[0].trim();\n  }\n\n  const realIp = headers.get('x-real-ip');\n  if (realIp) {\n    return realIp;\n  }\n\n  // Vercel-specific\n  const vercelIp = headers.get('x-vercel-forwarded-for');\n  if (vercelIp) {\n    return vercelIp.split(',')[0].trim();\n  }\n\n  return 'unknown';\n}\n\n/**\n * Check rate limit for a request\n * Returns result with ok=true if under limit, ok=false if rate limited\n */\nexport function checkRateLimit(\n  request: Request,\n  options: RateLimitOptions\n): RateLimitResult {\n  const { windowMs, max, prefix = 'ratelimit' } = options;\n  const ip = getClientIp(request);\n  const key = `${prefix}:${ip}`;\n\n  const entry = store.increment(key, windowMs);\n\n  return {\n    ok: entry.count <= max,\n    remaining: Math.max(0, max - entry.count),\n    limit: max,\n    resetAt: entry.resetAt,\n  };\n}\n\n/**\n * Add rate limit headers to a Response\n */\nexport function withRateLimitHeaders(\n  response: Response,\n  result: RateLimitResult\n): Response {\n  const headers = new Headers(response.headers);\n  headers.set('X-RateLimit-Limit', String(result.limit));\n  headers.set('X-RateLimit-Remaining', String(result.remaining));\n  headers.set('X-RateLimit-Reset', String(Math.ceil(result.resetAt / 1000)));\n\n  return new Response(response.body, {\n    status: response.status,\n    statusText: response.statusText,\n    headers,\n  });\n}\n","export { generateApiKey, hashApiKey, isValidKeyFormat } from './api-keys';\n// NOTE: spec-diff and spec-cache are NOT exported here to avoid SDK dependency\n// Routes that need them should import SDK directly with runtime = 'nodejs'\n"],"names":[],"mappings":"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"}