{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://unpkg.com/@openpkg-ts/spec/schemas/v0.3.0/openpkg.schema.json",
  "title": "OpenPkg Specification",
  "description": "Schema for OpenPkg specification files",
  "type": "object",
  "required": ["openpkg", "meta", "exports"],
  "properties": {
    "$schema": {
      "type": "string",
      "description": "Reference to the OpenPkg schema version",
      "pattern": "^(https://raw\\.githubusercontent\\.com/ryanwaits/openpkg/main/schemas/v[0-9]+\\.[0-9]+\\.[0-9]+/openpkg\\.schema\\.json|https://unpkg\\.com/@openpkg-ts/spec/schemas/v[0-9]+\\.[0-9]+\\.[0-9]+/openpkg\\.schema\\.json)$"
    },
    "openpkg": {
      "type": "string",
      "description": "OpenPkg specification version",
      "pattern": "^[0-9]+\\.[0-9]+\\.[0-9]+$",
      "const": "0.3.0"
    },
    "meta": {
      "type": "object",
      "description": "Package metadata",
      "required": ["name"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Package name"
        },
        "version": {
          "type": "string",
          "description": "Package version"
        },
        "description": {
          "type": "string",
          "description": "Package description"
        },
        "license": {
          "type": "string",
          "description": "Package license"
        },
        "repository": {
          "type": "string",
          "description": "Repository URL"
        },
        "ecosystem": {
          "type": "string",
          "description": "Package ecosystem"
        }
      }
    },
    "exports": {
      "type": "array",
      "description": "List of exported items",
      "items": {
        "$ref": "#/$defs/export"
      }
    },
    "types": {
      "type": "array",
      "description": "List of type definitions",
      "items": {
        "$ref": "#/$defs/typeDef"
      }
    },
    "docs": {
      "$ref": "#/$defs/docsMetadata",
      "description": "Aggregate documentation coverage metadata"
    }
  },
  "$defs": {
    "docSignal": {
      "type": "string",
      "enum": ["description", "params", "returns", "examples"]
    },
    "docDrift": {
      "type": "object",
      "required": ["type", "issue"],
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "param-mismatch",
            "param-type-mismatch",
            "return-type-mismatch",
            "generic-constraint-mismatch",
            "optionality-mismatch",
            "deprecated-mismatch",
            "visibility-mismatch",
            "async-mismatch",
            "property-type-drift",
            "example-drift",
            "example-syntax-error",
            "example-runtime-error",
            "example-assertion-failed",
            "broken-link"
          ]
        },
        "target": {
          "type": "string",
          "description": "Relevant identifier (e.g., parameter name)"
        },
        "issue": {
          "type": "string",
          "description": "Human-friendly drift explanation"
        },
        "suggestion": {
          "type": "string",
          "description": "Optional remediation hint"
        }
      },
      "additionalProperties": false
    },
    "docsMetadata": {
      "type": "object",
      "description": "Documentation coverage metadata",
      "additionalProperties": false,
      "properties": {
        "coverageScore": {
          "type": "number",
          "minimum": 0,
          "maximum": 100,
          "description": "Documentation coverage value from 0-100."
        },
        "missing": {
          "type": "array",
          "description": "Doc components missing for this entity",
          "items": {
            "$ref": "#/$defs/docSignal"
          },
          "uniqueItems": true
        },
        "drift": {
          "type": "array",
          "description": "Detected documentation drift signals",
          "items": {
            "$ref": "#/$defs/docDrift"
          }
        }
      }
    },
    "export": {
      "type": "object",
      "required": ["id", "name", "kind"],
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the export"
        },
        "name": {
          "type": "string",
          "description": "Export name"
        },
        "slug": {
          "type": "string",
          "description": "Stable slug for linking"
        },
        "displayName": {
          "type": "string",
          "description": "UI-friendly label"
        },
        "alias": {
          "type": "string",
          "description": "Export alias if re-exported with a different name (id uses alias, name uses original)"
        },
        "category": {
          "type": "string",
          "description": "Grouping hint for navigation"
        },
        "importPath": {
          "type": "string",
          "description": "Recommended import path"
        },
        "kind": {
          "type": "string",
          "description": "Kind of export",
          "enum": [
            "function",
            "class",
            "variable",
            "interface",
            "type",
            "enum",
            "namespace",
            "external"
          ]
        },
        "description": {
          "type": "string",
          "description": "JSDoc/TSDoc description"
        },
        "examples": {
          "type": "array",
          "description": "Usage examples from documentation",
          "items": {
            "type": "string"
          }
        },
        "signatures": {
          "type": "array",
          "description": "Function/method signatures",
          "items": {
            "$ref": "#/$defs/signature"
          }
        },
        "type": {
          "description": "Type reference or inline schema for variables",
          "oneOf": [{ "type": "string" }, { "$ref": "#/$defs/schema" }]
        },
        "members": {
          "type": "array",
          "description": "Class/interface/enum members",
          "items": { "type": "object" }
        },
        "extends": {
          "type": "string",
          "description": "Base class or interface that this class/interface extends"
        },
        "implements": {
          "type": "array",
          "description": "Interfaces implemented by this class",
          "items": { "type": "string" }
        },
        "tags": {
          "type": "array",
          "description": "JSDoc/TSDoc tags",
          "items": {
            "$ref": "#/$defs/tag"
          }
        },
        "source": {
          "$ref": "#/$defs/sourceLocation"
        },
        "docs": {
          "$ref": "#/$defs/docsMetadata",
          "description": "Documentation coverage metadata for this export"
        },
        "typeAliasKind": {
          "$ref": "#/$defs/typeAliasKind",
          "description": "Kind of type alias (for type exports)"
        },
        "conditionalType": {
          "$ref": "#/$defs/conditionalType",
          "description": "Structural details for conditional types"
        },
        "mappedType": {
          "$ref": "#/$defs/mappedType",
          "description": "Structural details for mapped types"
        },
        "decorators": {
          "type": "array",
          "description": "Decorators applied to this export (class/function)",
          "items": { "$ref": "#/$defs/decorator" }
        },
        "isAugmentation": {
          "type": "boolean",
          "description": "True if this is a module augmentation (declare module)"
        },
        "augmentedModule": {
          "type": "string",
          "description": "The module being augmented (e.g., 'express')"
        }
      }
    },
    "typeDef": {
      "type": "object",
      "required": ["id", "name", "kind"],
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the type"
        },
        "name": {
          "type": "string",
          "description": "Type name"
        },
        "slug": {
          "type": "string",
          "description": "Stable slug for linking"
        },
        "displayName": {
          "type": "string",
          "description": "UI-friendly label"
        },
        "alias": {
          "type": "string",
          "description": "Export alias if re-exported with a different name (id uses alias, name uses original)"
        },
        "category": {
          "type": "string",
          "description": "Grouping hint for navigation"
        },
        "importPath": {
          "type": "string",
          "description": "Recommended import path"
        },
        "kind": {
          "type": "string",
          "description": "Kind of type definition",
          "enum": ["interface", "type", "enum", "class", "external"]
        },
        "description": {
          "type": "string",
          "description": "JSDoc/TSDoc description"
        },
        "schema": {
          "$ref": "#/$defs/schema"
        },
        "type": {
          "type": "string",
          "description": "Type expression for type aliases"
        },
        "members": {
          "type": "array",
          "description": "Members for classes/interfaces/enums",
          "items": { "type": "object" }
        },
        "extends": {
          "type": "string",
          "description": "Base class or interface that this class/interface extends"
        },
        "implements": {
          "type": "array",
          "description": "Interfaces implemented by this class",
          "items": { "type": "string" }
        },
        "tags": {
          "type": "array",
          "description": "JSDoc/TSDoc tags",
          "items": {
            "$ref": "#/$defs/tag"
          }
        },
        "source": {
          "$ref": "#/$defs/sourceLocation"
        },
        "typeAliasKind": {
          "$ref": "#/$defs/typeAliasKind",
          "description": "Kind of type alias"
        },
        "conditionalType": {
          "$ref": "#/$defs/conditionalType",
          "description": "Structural details for conditional types"
        },
        "mappedType": {
          "$ref": "#/$defs/mappedType",
          "description": "Structural details for mapped types"
        }
      }
    },
    "tag": {
      "type": "object",
      "description": "JSDoc/TSDoc tag with optional structured fields",
      "required": ["name", "text"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Tag name (e.g., 'param', 'returns', 'deprecated')"
        },
        "text": {
          "type": "string",
          "description": "Full tag text content"
        },
        "paramName": {
          "type": "string",
          "description": "For @param tags: the parameter name"
        },
        "typeAnnotation": {
          "type": "string",
          "description": "For @param/@returns: type annotation if present"
        },
        "reference": {
          "type": "string",
          "description": "For @see/@link: resolved URL or symbol reference"
        },
        "language": {
          "type": "string",
          "description": "For @example: code language hint (e.g., 'typescript', 'json')"
        },
        "version": {
          "type": "string",
          "description": "For @since/@version: semver value"
        },
        "reason": {
          "type": "string",
          "description": "For @deprecated: migration path or deprecation reason"
        }
      },
      "additionalProperties": true
    },
    "signature": {
      "type": "object",
      "properties": {
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/parameter"
          }
        },
        "returns": {
          "$ref": "#/$defs/returns"
        },
        "description": {
          "type": "string",
          "description": "Signature-level description"
        },
        "typeParameters": {
          "type": "array",
          "description": "Generic type parameters for this signature",
          "items": {
            "$ref": "#/$defs/typeParameter"
          }
        },
        "overloadIndex": {
          "type": "integer",
          "minimum": 0,
          "description": "Index of this overload (0-based), undefined for single signatures"
        },
        "isImplementation": {
          "type": "boolean",
          "description": "True if this is the implementation signature (not user-callable)"
        },
        "throws": {
          "type": "array",
          "description": "Exceptions that can be thrown by this signature",
          "items": { "$ref": "#/$defs/throwsInfo" }
        }
      }
    },
    "typeParameter": {
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Type parameter name (e.g., 'T', 'K')"
        },
        "constraint": {
          "type": "string",
          "description": "Type constraint (e.g., 'extends string')"
        },
        "default": {
          "type": "string",
          "description": "Default type value"
        }
      }
    },
    "parameter": {
      "type": "object",
      "required": ["name", "required"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Parameter name"
        },
        "required": {
          "type": "boolean",
          "description": "Whether the parameter is required"
        },
        "schema": {
          "$ref": "#/$defs/schema"
        },
        "description": {
          "type": "string",
          "description": "Parameter description"
        },
        "default": {
          "description": "Default value for the parameter"
        },
        "rest": {
          "type": "boolean",
          "description": "Whether this is a rest parameter (...args)"
        },
        "decorators": {
          "type": "array",
          "description": "Decorators applied to this parameter",
          "items": { "$ref": "#/$defs/decorator" }
        }
      }
    },
    "returns": {
      "type": "object",
      "properties": {
        "schema": {
          "$ref": "#/$defs/schema"
        },
        "description": {
          "type": "string",
          "description": "Return value description"
        }
      }
    },
    "schema": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "object",
          "properties": {
            "$ref": {
              "type": "string",
              "description": "Reference to another type",
              "pattern": "^#/types/[A-Za-z0-9_.-]+$"
            }
          },
          "required": ["$ref"],
          "additionalProperties": false
        },
        {
          "type": "object",
          "not": {
            "required": ["$ref"]
          },
          "additionalProperties": true
        }
      ]
    },
    "sourceLocation": {
      "type": "object",
      "required": ["file", "line"],
      "properties": {
        "file": {
          "type": "string",
          "description": "Source file path"
        },
        "line": {
          "type": "integer",
          "description": "Line number in source file",
          "minimum": 1
        }
      }
    },
    "typeAliasKind": {
      "type": "string",
      "description": "Kind of type alias",
      "enum": ["alias", "conditional", "mapped", "template-literal", "infer"]
    },
    "conditionalType": {
      "type": "object",
      "description": "Structural representation of a conditional type (T extends X ? Y : Z)",
      "required": ["checkType", "extendsType", "trueType", "falseType"],
      "properties": {
        "checkType": {
          "type": "string",
          "description": "The type being checked (T)"
        },
        "extendsType": {
          "type": "string",
          "description": "The constraint type (X)"
        },
        "trueType": {
          "type": "string",
          "description": "The type when condition is true (Y)"
        },
        "falseType": {
          "type": "string",
          "description": "The type when condition is false (Z)"
        }
      },
      "additionalProperties": false
    },
    "mappedType": {
      "type": "object",
      "description": "Structural representation of a mapped type ({ [K in keyof T]: ... })",
      "required": ["typeParameter"],
      "properties": {
        "typeParameter": {
          "type": "string",
          "description": "The type parameter clause (e.g., 'K in keyof T')"
        },
        "nameType": {
          "type": "string",
          "description": "The 'as' clause for key remapping (TS 4.1+)"
        },
        "valueType": {
          "type": "string",
          "description": "The mapped value type"
        },
        "readonly": {
          "description": "Readonly modifier (+, -, or true for present)",
          "oneOf": [{ "type": "boolean" }, { "enum": ["+", "-"] }]
        },
        "optional": {
          "description": "Optional modifier (+, -, or true for present)",
          "oneOf": [{ "type": "boolean" }, { "enum": ["+", "-"] }]
        }
      },
      "additionalProperties": false
    },
    "decorator": {
      "type": "object",
      "description": "Decorator applied to a class, member, or parameter",
      "required": ["name"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Decorator name (e.g., 'Injectable', 'Component')"
        },
        "arguments": {
          "type": "array",
          "description": "Evaluated decorator arguments (if possible)"
        },
        "argumentsText": {
          "type": "array",
          "description": "Raw text of decorator arguments",
          "items": { "type": "string" }
        }
      },
      "additionalProperties": false
    },
    "throwsInfo": {
      "type": "object",
      "description": "Information about an exception that can be thrown",
      "properties": {
        "type": {
          "type": "string",
          "description": "Exception type (e.g., 'ValidationError', 'Error')"
        },
        "description": {
          "type": "string",
          "description": "When/why the exception is thrown"
        }
      },
      "additionalProperties": false
    }
  }
}
