import * as path from 'node:path';
import type { DocsImpactResult, MemberChange, SpecDiffWithDocs } from '@doccov/sdk';

/**
 * Data structure for diff report rendering
 */
export interface DiffReportData extends SpecDiffWithDocs {
  baseName: string;
  headName: string;
}

function bar(pct: number, width = 10): string {
  const filled = Math.round((pct / 100) * width);
  return '█'.repeat(filled) + '░'.repeat(width - filled);
}

function formatDelta(delta: number): string {
  if (delta > 0) return `+${delta}%`;
  if (delta < 0) return `${delta}%`;
  return '0%';
}

/**
 * Render a diff report as markdown
 */
export function renderDiffMarkdown(data: DiffReportData, options: { limit?: number } = {}): string {
  const limit = options.limit ?? 10;
  const lines: string[] = [];

  // Header
  lines.push(`# DocCov Diff Report`);
  lines.push('');
  lines.push(`**Comparing:** \`${data.baseName}\` → \`${data.headName}\``);
  lines.push('');

  // Coverage Summary
  lines.push('## Coverage Summary');
  lines.push('');
  const deltaIndicator = data.coverageDelta > 0 ? '↑' : data.coverageDelta < 0 ? '↓' : '→';
  lines.push(`| Metric | Base | Head | Delta |`);
  lines.push(`|--------|------|------|-------|`);
  lines.push(
    `| Coverage | ${data.oldCoverage}% | ${data.newCoverage}% | ${deltaIndicator} ${formatDelta(data.coverageDelta)} |`,
  );
  lines.push(`| Breaking Changes | - | ${data.breaking.length} | - |`);
  lines.push(`| New Exports | - | ${data.nonBreaking.length} | - |`);
  lines.push(`| New Undocumented | - | ${data.newUndocumented.length} | - |`);

  if (data.driftIntroduced > 0 || data.driftResolved > 0) {
    const driftDelta =
      data.driftIntroduced > 0
        ? `+${data.driftIntroduced}`
        : data.driftResolved > 0
          ? `-${data.driftResolved}`
          : '0';
    lines.push(`| Drift | - | - | ${driftDelta} |`);
  }

  // Breaking Changes
  if (data.breaking.length > 0) {
    lines.push('');
    lines.push('## Breaking Changes');
    lines.push('');

    const categorized = data.categorizedBreaking ?? [];
    const highSeverity = categorized.filter((c) => c.severity === 'high');
    const otherSeverity = categorized.filter((c) => c.severity !== 'high');

    if (highSeverity.length > 0) {
      lines.push('### High Severity');
      lines.push('');
      lines.push('| Name | Kind | Reason |');
      lines.push('|------|------|--------|');
      for (const c of highSeverity.slice(0, limit)) {
        lines.push(`| \`${c.name}\` | ${c.kind} | ${c.reason} |`);
      }
      if (highSeverity.length > limit) {
        lines.push(`| ... | | ${highSeverity.length - limit} more |`);
      }
      lines.push('');
    }

    if (otherSeverity.length > 0) {
      lines.push('### Medium/Low Severity');
      lines.push('');
      lines.push('| Name | Kind | Reason |');
      lines.push('|------|------|--------|');
      for (const c of otherSeverity.slice(0, limit)) {
        lines.push(`| \`${c.name}\` | ${c.kind} | ${c.reason} |`);
      }
      if (otherSeverity.length > limit) {
        lines.push(`| ... | | ${otherSeverity.length - limit} more |`);
      }
      lines.push('');
    }
  }

  // Member Changes
  if (data.memberChanges && data.memberChanges.length > 0) {
    lines.push('');
    lines.push('## Member Changes');
    lines.push('');

    // Group by class
    const byClass = groupMemberChangesByClass(data.memberChanges);

    for (const [className, changes] of byClass) {
      lines.push(`### ${className}`);
      lines.push('');
      lines.push('| Member | Change | Details |');
      lines.push('|--------|--------|---------|');

      for (const mc of changes.slice(0, limit)) {
        const details = getChangeDetails(mc);
        lines.push(`| \`${mc.memberName}()\` | ${mc.changeType} | ${details} |`);
      }
      if (changes.length > limit) {
        lines.push(`| ... | | ${changes.length - limit} more |`);
      }
      lines.push('');
    }
  }

  // New Exports
  if (data.nonBreaking.length > 0) {
    lines.push('');
    lines.push('## New Exports');
    lines.push('');

    const undocSet = new Set(data.newUndocumented);
    lines.push('| Export | Documented |');
    lines.push('|--------|------------|');

    for (const name of data.nonBreaking.slice(0, limit)) {
      const documented = undocSet.has(name) ? 'No' : 'Yes';
      lines.push(`| \`${name}\` | ${documented} |`);
    }
    if (data.nonBreaking.length > limit) {
      lines.push(`| ... | ${data.nonBreaking.length - limit} more |`);
    }
  }

  // Docs Impact
  if (data.docsImpact) {
    renderDocsImpactSection(lines, data.docsImpact, limit);
  }

  // Footer
  lines.push('');
  lines.push('---');
  lines.push('*Generated by [DocCov](https://doccov.com)*');

  return lines.join('\n');
}

function groupMemberChangesByClass(changes: MemberChange[]): Map<string, MemberChange[]> {
  const byClass = new Map<string, MemberChange[]>();
  for (const mc of changes) {
    const list = byClass.get(mc.className) ?? [];
    list.push(mc);
    byClass.set(mc.className, list);
  }
  return byClass;
}

function getChangeDetails(mc: MemberChange): string {
  if (mc.changeType === 'removed') {
    return mc.suggestion ? `→ ${mc.suggestion}` : 'removed';
  }
  if (mc.changeType === 'signature-changed') {
    if (mc.oldSignature && mc.newSignature) {
      return `\`${mc.oldSignature}\` → \`${mc.newSignature}\``;
    }
    return 'signature changed';
  }
  if (mc.changeType === 'added') {
    return 'new';
  }
  return '-';
}

function renderDocsImpactSection(
  lines: string[],
  docsImpact: DocsImpactResult,
  limit: number,
): void {
  const { impactedFiles, missingDocs, stats, allUndocumented } = docsImpact;

  lines.push('');
  lines.push('## Documentation Impact');
  lines.push('');
  lines.push(
    `Scanned **${stats.filesScanned}** files, **${stats.codeBlocksFound}** code blocks, **${stats.referencesFound}** references.`,
  );
  lines.push('');

  if (impactedFiles.length === 0 && missingDocs.length === 0) {
    lines.push('No documentation updates required.');
    return;
  }

  // Impacted files
  if (impactedFiles.length > 0) {
    lines.push('### Files Requiring Updates');
    lines.push('');
    lines.push('| File | Issues | Details |');
    lines.push('|------|--------|---------|');

    for (const file of impactedFiles.slice(0, limit)) {
      const filename = path.basename(file.file);
      const issueCount = file.references.length;
      const firstRef = file.references[0];
      const detail = firstRef
        ? `L${firstRef.line}: ${firstRef.memberName ?? firstRef.exportName}`
        : '-';
      lines.push(`| \`${filename}\` | ${issueCount} | ${detail} |`);
    }
    if (impactedFiles.length > limit) {
      lines.push(`| ... | | ${impactedFiles.length - limit} more files |`);
    }
    lines.push('');
  }

  // Missing docs for new exports
  if (missingDocs.length > 0) {
    lines.push('### New Exports Missing Documentation');
    lines.push('');
    lines.push('| Export |');
    lines.push('|--------|');
    for (const name of missingDocs.slice(0, limit)) {
      lines.push(`| \`${name}\` |`);
    }
    if (missingDocs.length > limit) {
      lines.push(`| ... ${missingDocs.length - limit} more |`);
    }
    lines.push('');
  }

  // Overall documentation coverage
  if (allUndocumented && allUndocumented.length > 0 && stats.totalExports > 0) {
    const docPercent = Math.round(
      ((stats.totalExports - allUndocumented.length) / stats.totalExports) * 100,
    );
    lines.push('### Documentation Coverage');
    lines.push('');
    lines.push(
      `**${stats.documentedExports}/${stats.totalExports}** exports documented (${docPercent}%) \`${bar(docPercent)}\``,
    );
    lines.push('');
  }
}
